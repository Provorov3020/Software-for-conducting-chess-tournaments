<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>Турниры</title>
    <link rel="stylesheet" href="Tournaments.css"/>
	<main>
	<nav>
	    <a href="tournaments.html">Турниры</a>
	    <a href="chess-tournament.html">Главная</a>
	</nav>
<section id="createTournamentSection">
	   <h2>Создать турнир</h2>
	   <form id="createTournamentForm">
            <label for="tournamentName">Название турнира</label>
            <input type="text" id="tournamentName" required />
			<label for="tournamentDate">Дата проведения</label>
			<input type="date" id="tournamentDate" required />
			<label for="tournamentTime">Время начала проведения</label>
			<input type="time" id="tournamentTime" required />
			<label for="playerCount">Количество участников (2-10)</label>
			<input type="number" id="playerCount" min="2" max="10" value="2" required />
			<button type="submit">Создать турнир</button>	
			</form>
			<div class="error" id="createTournamentError">
      </div>
	  <div id="tournamentInfoCreate"></div>
      <div id="playersList"></div>
      <div id="chessBoard"></div>
          </section>	
<div class="controls">
  <button id="btnStart">Запуск игры</button>
  <button id="btnPause" disabled>Пауза</button>
  <button id="btnResume" disabled>Возобновить</button>
  <button id="btnEnd" disabled>Завершить игру</button>
  
</div>
	
<div class="chessboard" aria-label="Шахматное поле"></div>

<div id="result"></div>
</head>
<body>
<script>
  
const chessboard = document.querySelector('.chessboard');
  const size = 8;
  let boardState = [
    ["♜","♞","♝","♛","♚","♝","♞","♜"],
    ["♟","♟","♟","♟","♟","♟","♟","♟"],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    [".",".",".",".",".",".",".","."],
    ["♙","♙","♙","♙","♙","♙","♙","♙"],
    ["♖","♘","♗","♕","♔","♗","♘","♖"]
  ];
  let selectedCell = null;
  let selectedPos = null;
  let turn = 'white'; // Ходят белые сеичас, потом чёрные и так далее
  let gameActive = false; // разрешена ли игра
  const resultDiv = document.getElementById('result');
  // Кнопки
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnResume = document.getElementById('btnResume');
  const btnEnd = document.getElementById('btnEnd');

  btnStart.addEventListener('click', () => {
    if (!gameActive) {
      gameActive = true;
      turn = 'white';
      selectedCell = null;
      selectedPos = null;
      resultDiv.textContent = 'Игра началась. Ходят белые.';
	  
	  // Заново расставляем фигуры по стартовой позиции (сброс состояния)
    boardState = [
      ["♜","♞","♝","♛","♚","♝","♞","♜"],
      ["♟","♟","♟","♟","♟","♟","♟","♟"],
      [".",".",".",".",".",".",".","."],
      [".",".",".",".",".",".",".","."],
      [".",".",".",".",".",".",".","."],
      [".",".",".",".",".",".",".","."],
      ["♙","♙","♙","♙","♙","♙","♙","♙"],
      ["♖","♘","♗","♕","♔","♗","♘","♖"]
    ];

      btnStart.disabled = true;
      btnPause.disabled = false;
      btnResume.disabled = true;
      btnEnd.disabled = false;
      createBoard();
    }
  });
   btnPause.addEventListener('click', () => {
    if (gameActive) {
      gameActive = false;
      deselectCell();
      resultDiv.textContent = 'Игра на паузе...';
      btnPause.disabled = true;
      btnResume.disabled = false;
    }
  });

  btnResume.addEventListener('click', () => {
    if (!gameActive) {
      gameActive = true;
      resultDiv.textContent = `Игра возобновлена. Ходят ${turn === 'white' ? 'белые' : 'чёрные'}.`;
      btnPause.disabled = false;
      btnResume.disabled = true;
    }
  });

  btnEnd.addEventListener('click', () => {
    if (gameActive || btnStart.disabled) {
      gameActive = false;
      deselectCell();
      resultDiv.textContent = 'Игра завершена.';
      btnStart.disabled = false;
      btnPause.disabled = true;
      btnResume.disabled = true;
      btnEnd.disabled = true;
      // Можно добавить здесь логику подсчёта и объявления победителя (упрощённо, как пример)
      announceWinner();
    }
  });
  

  function createBoard() {
    chessboard.innerHTML = '';
   for (let row = 0; row < size; row++) {
    for (let col = 0; col < size; col++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');	  
      // Определяем цвет клетки
      if ((row + col) % 2 === 0) {
        cell.classList.add('light');
      } else {
        cell.classList.add('dark');
      }
	  cell.dataset.row = row;
      cell.dataset.col = col;

      const piece = boardState[row][col];
      if (piece !== '.') {
        const pieceSpan = document.createElement('span');
        pieceSpan.textContent = piece;
        // Определяем цвет фигуры
        pieceSpan.classList.add(row <= 1 ? 'black-piece' : 'white-piece');
        cell.appendChild(pieceSpan);
      }
      cell.addEventListener('click', onCellClick);
      chessboard.appendChild(cell);
    }
  }
}

// Проверяем, находится ли король цвета turn под шахом
function isCheck(turn) {
  const kingPos = findKingPosition(turn);
  if (!kingPos) return false; // нет короля, значит игра окончена
  
  // Проверяем, атакуют ли какую-либо фигуру соперника позиции короля
  const opponent = (turn === 'white') ? 'black' : 'white';
  return isSquareAttacked(kingPos.row, kingPos.col, opponent);
}

// Проверка, есть ли мат у игрока turn
function isCheckmate(turn) {
  if (!isCheck(turn)) return false; // мат только если шах

  // Если нет ни одного хода, который выводит из шаха — мат
  const moves = generateAllLegalMoves(turn);
  for (let move of moves) {
    if (!wouldBeInCheckAfterMove(move, turn)) {
      return false; // есть ход, избавляющий от шаха
    }
  }
  return true;
}

// Проверка пата для игрока turn
function isStalemate(turn) {
  if (isCheck(turn)) return false; // не пат, если шах
  const moves = generateAllLegalMoves(turn);
  // если ходов нет и шаха нет — пат
  return moves.length === 0;
}

// Пример вспомогательной функции: найти позицию короля
function findKingPosition(turn) {
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (piece && piece.type === 'king' && piece.color === turn) {
        return {row: r, col: c};
      }
    }
  }
  return null; // не найден король
}

// Проверяем атакована ли клетка (row,col) фигурой цвета attackerColor
function isSquareAttacked(row, col, attackerColor) {
  // Итерация по всем фигурам attackerColor, проверка возможности захвата клетки (row,col)
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (piece && piece.color === attackerColor) {
        if (canMove(r, c, row, col, attackerColor, true)) { 
          // последний параметр true — игнорировать шахи для самоопределения атак (опционально)
          return true;
        }
      }
    }
  }
  return false;
}

// Генерируем все легальные ходы для игрока turn
function generateAllLegalMoves(turn) {
  const moves = [];
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const piece = board[r][c];
      if (piece && piece.color === turn) {
        for (let tr = 0; tr < 8; tr++) {
          for (let tc = 0; tc < 8; tc++) {
            if ((r !== tr || c !== tc) && canMove(r, c, tr, tc, turn)) {
              moves.push({from: {row: r, col: c}, to: {row: tr, col: tc}});
            }
          }
        }
      }
    }
  }
  return moves;
}

// Проверка, будет ли шах после выполнения данного хода
function wouldBeInCheckAfterMove(move, turn) {
  // Сохраняем текущую доску
  const tempBoard = copyBoard(board);

  // Выполняем ход на временной доске
  makeMoveOnBoard(tempBoard, move.from.row, move.from.col, move.to.row, move.to.col);

  // Проверяем шах после хода
  const kingPos = findKingPosition(turn, tempBoard);
  if (!kingPos) return true; // нет короля - значит шах
  
  return isSquareAttackedOnBoard(tempBoard, kingPos.row, kingPos.col, (turn === 'white') ? 'black' : 'white');
}
// Подсветка короля шаха (например добавление css класса)
function highlightKing(turn) {
  const pos = findKingPosition(turn);
  if (!pos) return;
  const cell = document.querySelector(`[data-row='${pos.row}'][data-col='${pos.col}']`);
  if (cell) cell.classList.add('highlight-check');
}

// Снятие подсветки шаха с короля
function clearKingHighlight() {
  document.querySelectorAll('.highlight-check').forEach(cell => cell.classList.remove('highlight-check'));
}

// Помощник: ищет позицию короля цвета turn
function findKing(board, turn) {
  const kingChar = turn === 'white' ? 'K' : 'k';
  for (let r = 0; r < size; r++) {
    for (let c = 0; c < size; c++) {
      if (board[r][c] === kingChar) {
        return {row: r, col: c};
      }
    }
  }
  return null;
}

function updateScore(side, points) {
  // Логика обновления очков для игроков  
  // Например, score белых и чёрных в переменных whiteScore, blackScore
  if (side === 'white') whiteScore += points;
  else if (side === 'black') blackScore += points;
  updateScoreDisplay();
}

function onCellClick(e) {
    if (!gameActive) return; // перемещать фигуры можно только при активной игре
    const cell = e.currentTarget;
    const row = +cell.dataset.row;
    const col = +cell.dataset.col;
    const piece = boardState[row][col];
    const isTurnWhite = (turn === 'white');
    // Если ничего не выделено, выбираем фигуру (свою фигуру)
	 if (selectedCell === null) {
      if (piece === '.') {
        alert("Выберите фигуру для хода");
        return;
      }
	  if (isTurnWhite && !isWhitePiece(piece)) {
        alert("Сейчас ходят белые");
        return;
      }
      if (!isTurnWhite && !isBlackPiece(piece)) {
        alert("Сейчас ходят чёрные");
        return;
      }      
      selectCell(cell, row, col);
      return;
    }
	// Если кликнули по той же клетке - снимаем выделение
    if (row === selectedPos.row && col === selectedPos.col) {
      deselectCell();
      return;
    }

 	// Проверяем ход на допустимость
    if (canMove(selectedPos.row, selectedPos.col, row, col, turn)) {
      doMove(selectedPos.row, selectedPos.col, row, col);
	  deselectCell();
	   
   
	 // Смена хода
    turn = (turn === 'white') ? 'black' : 'white';
	resultDiv.textContent = `Ходят ${turn === 'white' ? 'белые' : 'чёрные'}.`;
} else {
    alert("Неверный ход или клетка занята или ход не по правилам");
  }
}  	  
  function selectCell(cell, row, col) {
    selectedCell = cell;
    selectedPos = { row, col };
    cell.classList.add('selected');
  }

  function deselectCell() {
    if (selectedCell) {
      selectedCell.classList.remove('selected');
      selectedCell = null;
      selectedPos = null;
    }
  }

  function isWhitePiece(piece) {
    return "♙♖♘♗♕♔".includes(piece);
  }

  function isBlackPiece(piece) {
    return "♟♜♞♝♛♚".includes(piece);
  }
  function boardHasKing(color) {
    const king = (color === 'white') ? '♔' : '♚';
    return boardState.flat().includes(king);
  }
  
  // 1. Функция построения карты атак фигурами игрока attackerColor.
// Возвращает двумерный массив 8x8 с true на позициях, которые атакует противник.
function buildAttackMap(attackerColor) {
  const attackMap = Array(8).fill(null).map(() => Array(8).fill(false));

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      if (board[r][c] && board[r][c].color === attackerColor) {
        // Для каждой фигуры attackerColor
        // Получаем все клетки, на которые она может бить (move для атаки)
        const attacks = getAttackedSquares(r, c, attackerColor);
        for (const pos of attacks) {
          attackMap[pos.row][pos.col] = true;
        }
      }
    }
  }

  return attackMap;
}

// 2. Функция получения клеток, которыми фигура на (row, col) атакует противника.
// Учитывает особенности ходов и атак фигур (например, пешка ходит и бьёт по-разному).
// Важно: король не атакует короля (не ставит шах ему).
function getAttackedSquares(row, col, color) {
  const piece = board[row][col];
  if (!piece) return [];
  const enemyColor = (color === 'white') ? 'black' : 'white';
  let attackedSquares = [];

  // Пример для пешки:
  if (piece.type === 'pawn') {
    const dir = (color === 'white') ? -1 : 1;
    const attackRows = [row + dir];
    const attackCols = [col - 1, col + 1];
    for (const r of attackRows) {
      for (const c of attackCols) {
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
          attackedSquares.push({row: r, col: c});
        }
      }
    }
  }
   // При этом для короля не добавляем клетки, занятые королём противника.
  // Пример для короля: клетки вокруг, но если там стоит вражеский король — не добавляем.
  if (piece.type === 'king') {
    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],          [0, 1],
      [1, -1],  [1, 0], [1, 1],
    ];
    for (const [dr, dc] of directions) {
      const nr = row + dr, nc = col + dc;
      if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
        const targetPiece = board[nr][nc];
        if (!targetPiece || targetPiece.color !== color) {
          if (!(targetPiece && targetPiece.type === 'king' && targetPiece.color === enemyColor)) {
            attackedSquares.push({row: nr, col: nc});
          }
        }
      }
    }
  }
  return attackedSquares;
}

  // Проверка на подвижность + основные шахматные правила ходов
  function canMove(fromRow, fromCol, toRow, toCol, turn)
    {
    const piece = boardState[fromRow][fromCol];
    const targetPiece = boardState[toRow][toCol];

    // Нельзя ходить на клетку со своей фигурой
    if (targetPiece !== '.') {
      if (turn === 'white' && isWhitePiece(targetPiece)) return false;
      if (turn === 'black' && isBlackPiece(targetPiece)) return false;
    }
	
	const deltaRow = toRow - fromRow;
	const deltaCol = toCol - fromCol;
	const adRow = Math.abs(deltaRow);
	const adCol = Math.abs(deltaCol);
	
    // Пешка
    if (piece === '♙' || piece === '♟') {
      const forward = (piece === '♙') ? -1 : 1; // белые идут вверх (row уменьшается)
      const startRow = (piece === '♙') ? 6 : 1;

      // Ход вперед
      if (deltaCol === 0) {
        if (deltaRow === forward && targetPiece === '.') return true;
        if (fromRow === startRow && deltaRow === 2 * forward &&
            targetPiece === '.' &&
            boardState[fromRow + forward][fromCol] === '.') return true;
        return false;
      }
	  
	  // По диагонали "поесть"
      if (adCol === 1 && deltaRow === forward && targetPiece !== '.') {
        if ((piece === '♙' && isBlackPiece(targetPiece)) ||
            (piece === '♟' && isWhitePiece(targetPiece))) return true;
        return false;
      }
      return false;
    }
	// Ладья ♖♜ - ходит по вертикали и горизонтали, любые клетки свободны
    if (piece === '♖' || piece === '♜') {
      if (deltaRow !== 0 && deltaCol !== 0) return false;
      if (!isPathClear(fromRow, fromCol, toRow, toCol)) return false;
      return true;
    }
	// Конь ♘♞ - ходит буквой "Г" (2+1)
    if (piece === '♘' || piece === '♞') {
      if ((adRow === 2 && adCol === 1) || (adRow === 1 && adCol === 2)) return true;
	  return false;
	  }
	  // Слон ♗♝ - по диагонали, путь свободен
    if (piece === '♗' || piece === '♝') {
      if (adRow !== adCol) return false;
      if (!isPathClear(fromRow, fromCol, toRow, toCol)) return false;
      return true;
    }
	
	 // Ферзь ♕♛ - сочетание ладьи и слона
    if (piece === '♕' || piece === '♛') {
      const straight = (deltaRow === 0 || deltaCol === 0);
      const diagonal = (adRow === adCol);
      if (!(straight || diagonal)) return false;
      if (!isPathClear(fromRow, fromCol, toRow, toCol)) return false;
      return true;
    }
	
	// Король ♔♚ - ходит на одну клетку в любом направлении
    if (piece === '♔' || piece === '♚') {
      if (adRow <= 1 && adCol <= 1) return true;
      return false;
    }

    return false;
  }
      

  // Проверка открытости пути (без учета коня, который может перепрыгивать)
  function isPathClear(fromRow, fromCol, toRow, toCol) {
    const deltaRow = toRow - fromRow;
    const deltaCol = toCol - fromCol;

    const stepRow = deltaRow === 0 ? 0 : deltaRow / Math.abs(deltaRow);
    const stepCol = deltaCol === 0 ? 0 : deltaCol / Math.abs(deltaCol);

    let currentRow = fromRow + stepRow;
    let currentCol = fromCol + stepCol;

    while (currentRow !== toRow || currentCol !== toCol) {
      if (boardState[currentRow][currentCol] !== '.') return false;
      currentRow += stepRow;
      currentCol += stepCol;
    }
    return true;
  }
  
  function doMove(fromRow, fromCol, toRow, toCol) {
    boardState[toRow][toCol] = boardState[fromRow][fromCol];
    boardState[fromRow][fromCol] = '.';

    updateCell(fromRow, fromCol);
    updateCell(toRow, toCol);
  }
  

  function updateCell(row, col) {
    const index = row * size + col;
    const cell = chessboard.children[index];
    cell.innerHTML = '';
    const piece = boardState[row][col];
    if (piece !== '.') {
      const span = document.createElement('span');
      span.textContent = piece;
	  span.classList.add(row <= 1 ? 'black-piece' : 'white-piece');
      cell.appendChild(span);
    }
  }

  createBoard();
</script>

</body>
</html>
